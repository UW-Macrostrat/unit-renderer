<!DOCTYPE html>
<meta charset="utf-8">
<title>Macrostrat section renderer</title>
<style>

.node {
  fill: #ddd;
  stroke: #000;
  stroke-width: 0.01em;
}

.label {
  font: 10px sans-serif;
  text-anchor: middle;
}

#column, #column2 {
  display: inline;
}

</style>
<body>
  <div id="column"></div>
  <div id="column2"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<!--<script src="d3.v3.min.js"></script>-->
<script>

var baseURL = (window.location.hostname === "localhost") ? "http://localhost:5000" : "http://dev.macrostrat.org"

function getSection(id) {
  d3.json(baseURL + "/api/units?response=long&section_id=" + id, function(error, data) {
    var units = data.success.data;

    var late_age = d3.min(units, function(d) { return d.LO_age }),
        early_age = d3.max(units, function(d) { return d.FO_age });
    
    getTimeIntervals(early_age, late_age, units);

  });
}


function getTimeIntervals(early, late, units) {
  // 1. Find all intervals that overlap this range
  d3.json(baseURL + "/api/defs/intervals?timescale=international&early_age=" + early + "&late_age=" + late, function(error, data) {
    // 2. Check if any periods were returned
    var periods = data.success.data.filter(function(d) {
      if (d.type === "period") {
        return d;
      }
    });

    // 2B. Otherwise, find the period that contains the midpoint of this range
    if (periods.length < 1) {
      d3.json(baseURL + "/api/defs/intervals?timescale=international&age=" + parseInt(((min + max) / 2)), function(error, data) {
        getAllIntervals(units, data.success.data);
      });

    // 2A. If so, continue on
    } else {
      if (d3.min(periods, function(d) { return d.late_age }) > late) {
        // Not late enough
        console.log("not late enough");
        d3.json(baseURL + "/api/defs/intervals?timescale=international&age=" + late, function(error, data) {
          var period = data.success.data.filter(function(d) {
            if (d.type === "period") {
              return d;
            }
          });
          periods.push(period[0]);
          getAllIntervals(units, periods);
        });
      } else if (d3.max(periods, function(d) { return d.early_age }) < early) {
        // Not early enough
        console.log("not early enough");
        d3.json(baseURL + "/api/defs/intervals?timescale=international&age=" + early, function(error, data) {
          var period = data.success.data.filter(function(d) {
            if (d.type === "period") {
              return d;
            }
          });
          periods.push(period[0]);
          getAllIntervals(units, periods);
        }); 
      } else {
        getAllIntervals(units, periods);
      }
    }
  });
}

function getAllIntervals(units, periods) {
  // 3. Find the late_age and early_age of all periods returned
  var late = d3.min(periods, function(d) { return d.late_age }),
      early = d3.max(periods, function(d) { return d.early_age });

  // Draw the units
  var scale = d3.scale.linear()
    .domain([late, early])
    .range([0, 800]);

  drawUnits(scale, units);

  // 4. Basically redo #1, but with this new range
  // Find all intervals in this period
  d3.json(baseURL + "/api/defs/intervals?timescale=international&early_age=" + early + "&late_age=" + late, function(error, data) {
    data.success.data.forEach(function(d) {
     // d.boundaries = 0;
      d.children = [];
      d.boundaries = [];
      d.t_boundaries = 0;
    });
    //countBoundaries(data.success.data, units);
    draw(data.success.data)
  });

}

function draw(data) {
  var width = 50,
      height = 800;

  d3.select("#column").select("svg").remove();

  var svg = d3.select("#column").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
        .attr("id", "timescale")
        .attr("data-zoomed", "false");;

  var scale = d3.scale.linear()
      .domain([d3.min(data, function(d) { return d.late_age }), d3.max(data, function(d) { return d.early_age})])
      .range([0, height])

  var interval_lookup = {
    "period": 0,
    "epoch": width * 0.3,
    "age": width * 0.6
  }

  svg.selectAll(".node")
    .data(data)
  .enter().append("rect")
    .attr("class", "node")
    .attr("id", function(d) { return "n" + d.name })
    .attr("x", function(d) { return interval_lookup[d.type] })
    .attr("y", function(d) { return scale(d.late_age) })
    .attr("width", width * 0.3)
    .attr("height", function(d) { return scale(d.early_age) - scale(d.late_age)})
    .style("fill", function(d) { return d.color })
    .on("click", function(d) {
      if (svg.attr("data-zoomed") === "false") {
        svg.attr("data-zoomed", "true");
        var translateY = d3.select(this).attr("y"),
            scaleY = 800/d3.select(this).attr("height");

        d3.selectAll("#timescale, #section")
          .transition()
          .duration(1000)
          .attr("transform", "scale(1," + scaleY + ")translate(0,-" + translateY + ")");
      } else {
        svg.attr("data-zoomed", "false");
        d3.selectAll("#timescale, #section")
          .transition()
          .duration(1000)
          .attr("transform", "scale(1,1)translate(0,0)");
      }
    });


/*
  svg.selectAll(".label")
    .data(data)
  .enter().append("text")
    .attr("class", "label")
    .attr("dy", ".35em")
    .attr("transform", function(d) { return "translate(" + (interval_lookup[d.type] + ((width * 0.3)/2)) + "," + ((scale(d.late_age) + scale(d.early_age))/2) + ")rotate(-90)"; })
    .text(function(d) { return d.name; });
*/
}

function drawUnits(scale, units) {
  var columns = [
    {
      'top': -1,
      'bottom': -1
    }
  ];
  units.forEach(function(d) {
    if (d.t_age > d.b_age) {
      console.log(d.strat_name + " IS BASS ACKWARDS");
      return;
    }
    var found = false;
    for (var i=0; i<columns.length; i++) {
      if (d.t_age >= columns[i].top && d.b_age <= columns[i].bottom) {
        // add new column
        console.log("a - " + d.strat_name)
      } else if (d.t_age < columns[i].top && d.b_age > columns[i].top) {
        // add new column
        console.log("b - " + d.strat_name)
      } else if (d.t_age < columns[i].bottom && d.t_age > columns[i].top) {
        // add new column
        console.log("c - " + d.strat_name)
      } else {
        console.log("d - " + d.strat_name)
        if (columns[i].top < 0) {
          columns[i].top = d.t_age;
        }

        columns[i].bottom = d.b_age;
        found = true;
        d.col = i;
        return;
      }
    }


    if (!found) {
      columns.push({'top': d.t_age, 'bottom': d.b_age});
      d.col = columns.length - 1;
    }

  });

  console.log(columns);

  var width = 300,
      height = 800;
      
  var svg = d3.select("#column2").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
      .attr("id", "section");

  svg.selectAll(".units")
    .data(units)
  .enter().append("rect")
    .attr("class", "node")
    .attr("id", function(d) { return d.strat_name })
    .attr("x", function(d) { return d.col * 50 })
    .attr("y", function(d) { return scale(d.t_age) })
    .attr("width", 50)
    .attr("height", function(d) { return scale(d.b_age) - scale(d.t_age)})
    .style("fill", function(d) { return d.color });
/*
  svg.selectAll(".unit_label")
    .data(units)
  .enter().append("text")
    .attr("class", "label")
    .attr("dy", ".35em")
    .attr("transform", function(d) { return "translate(" + (d.col * 50 + 25)  + "," + (scale(d.t_age) + (scale(d.b_age) - scale(d.t_age))/2) + ")rotate(-90)" })
    .text(function(d) { return d.strat_name; });
  */
}


var section = window.location.hash.replace("#/", "");
if (section.length > 0) {
  getSection(section);
} else {
  getSection(4258);
}


</script>

